;;; Teste 17 E2
;;; procura A* num tabuleiro onde nao existe solucao
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar IGNORE
(ignore-value (dotimes (linha 17) (dotimes (coluna 9) (tabuleiro-preenche! t1 linha coluna))))
;;deve retornar NIL (nao existe solucao)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(t s)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'qualidade) #'(lambda (e) 0))


;;; Teste 18 E2
;;; procura A* num tabuleiro vazio. Nao e possivel fazer nenhuma linha, por isso aqui testamos apenas se trabalham com a lista de abertos/fronteira de acordo com a ordem especificada
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(t s)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'qualidade) #'(lambda (x) 0))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(l i)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'custo-oportunidade) #'(lambda (x) 0))

;;; Teste 19 E2 
;;; procura A* num tabuleiro onde e possivel fazer 4 linhas com qualidade.
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar IGNORE
(ignore-value (dotimes (linha 10) (dotimes (coluna 8) (tabuleiro-preenche! t1 linha coluna))))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(l j)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'qualidade) #'(lambda (x) 0))


;;; Teste 20 E2
;;; procura A* num tabuleiro onde e possivel fazer 4 linhas com custo-oportunidade.
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar IGNORE
(ignore-value (dotimes (linha 10) (dotimes (coluna 8) (tabuleiro-preenche! t1 linha coluna))))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(j l)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'custo-oportunidade) #'(lambda (x) 0))

;;; Teste 21 E2 
;;; procura A* num tabuleiro quase cheio usando qualidade
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar IGNORE
(ignore-value (dotimes (linha 16) (dotimes (coluna 8) (tabuleiro-preenche! t1 linha coluna))))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(o l j)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'qualidade) #'(lambda (x) 0))


;;; Teste 22 E2
;;; procura A* num tabuleiro quase cheio usando custo oportunidade
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar IGNORE
(ignore-value (dotimes (linha 16) (dotimes (coluna 7) (tabuleiro-preenche! t1 linha coluna))))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(l j)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'custo-oportunidade) #'(lambda (x) 0))


;; Teste 23 E2
;;; procura A* num problema alternativo ao jogo do tetris, a implementacao da procura-A* deve ser independente do problema de procura
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (list 0 0 0) :accoes #'(lambda (e) (list 'up 'down 'left 'right)) :resultado #'(lambda (e a) (cond ((eq a 'up) (list (first e) (1+ (second e)) (1+ (third e))))((eq a 'down) (list (first e) (1- (second e)) (1+ (third e))))((eq a 'left) (list (1- (first e)) (second e) (1+ (third e))))(T (list (1+ (first e)) (second e) (1+ (third e)))))) :custo-caminho #'(lambda (e) (third e)) :solucao #'(lambda (e) (and (= (first e) 2)(= (second e) 3)))) #'(lambda (e) (+ (abs (- 2 (first e))) (abs (- 3 (second e))))))


;;; Teste 24 E2
;;; procura-best num jogo com apenas uma peca, e obrigatorio num tabuleiro tao simples retornar a jogada optima
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-best '#2A((T T T T NIL T T T T T)(T T T NIL NIL NIL T T T T)(T T T NIL NIL NIL T T T T)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)) '(t))


;;; Teste 25 E2
;;; procura-best num tabuleiro com 4 jogadadas por fazer. Os grupos tem um tempo limitado para conseguir obter pelo menos 500 pontos. 
;;; deve retornar IGNORE
(ignore-value (setf a1 '#2A((T T T T NIL NIL T T T T)(T T T NIL NIL NIL T T T T)(T T T NIL NIL NIL T T T T)(T T T NIL NIL NIL T T T T)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL))))
;;;deve retornar IGNORE
(ignore-value (setf r1 (procura-best a1 '(t i l l))))
;;;deve retornar T
(>= (executa-jogadas (make-estado :tabuleiro (array->tabuleiro a1) :pecas-por-colocar '(t i l l) :pontos 0 :pecas-colocadas '()) r1 NIL) 500)


;;; teste 26 E2, testa abstracao de dados do tipo tabuleiro, na funcoes procura-pp
(make-package 'teste)
(in-package teste)
;; o projecto nao pode ser compilado, pois iria ter problemas em redefinir estruturas compiladas em lisp
;; retorna T
(load "projecto-alunos.lisp") 
;; carrega um tipo tabuleiro mt particular, fazendo override as definicoes dos alunos
;; retorna T
(load "TAI-tabuleiro.lisp")
;; carrega o ficheiro de utils nao compilado
;; retorna T
(load "utils.lisp")
;;deve retornar IGNORE
(progn (setf t1 (cria-tabuleiro)) 'IGNORE)
;;deve retornar IGNORE
(progn (dotimes (linha 17) (dotimes (coluna 8) (tabuleiro-preenche! t1 linha (+ coluna 2)))) 'IGNORE)
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-pp (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1  :pecas-por-colocar '(o l t s z)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'(lambda (x) 0)))


;;; teste 27 E2, testa abstracao de dados do tipo tabuleiro, na funcoes procura-A*
(make-package 'teste)
(in-package teste)
;; o projecto nao pode ser compilado, pois iria ter problemas em redefinir estruturas compiladas em lisp
;; retorna T
(load "projecto-alunos.lisp") 
;; carrega um tipo tabuleiro mt particular, fazendo override as definicoes dos alunos
;; retorna T
(load "TAI-tabuleiro.lisp")
;; carrega o ficheiro de utils nao compilado
;; retorna T
(load "utils.lisp")
;;deve retornar IGNORE
(ignore-value (setf t1 (cria-tabuleiro)))
;;deve retornar IGNORE
(ignore-value (dotimes (linha 10) (dotimes (coluna 8) (tabuleiro-preenche! t1 linha coluna))))
;;deve retornar uma lista de accoes (ver ficheiro output)
(procura-A* (make-problema :estado-inicial (make-estado :pontos 0 :tabuleiro t1 :pecas-colocadas () :pecas-por-colocar '(l j)) :solucao #'solucao :accoes #'accoes :resultado #'resultado :custo-caminho #'qualidade) #'(lambda (x) 0))
